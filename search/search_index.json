{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Kastle is a text adventure engine. You can use it to run games in your terminal where you'll impersonate a hero and will instruct them about what to do by writing text commands.</p> <p>You can also use Kastle as a platform to develop your own text adventures.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Portable: Kastle runs on the JVM. Every computer with Java installed can run Kastle;</li> <li>Simple: Kastle games are simple jar files. The <code>kastle install</code> command will take care of managing the games;</li> <li>Narrative based: in Kastle there's no fight system. This leads to strongly narrative oriented games with fun stories and mechanics;</li> <li>Endless possibilities: Kastle is not focused on a specific lore or game style. Every story that involves a player navigating and environment and interacting with it can be told with Kastle! Save the princess, fix the starship, explore a western village or whatever you want</li> <li>Customizable: making a Kastle game is easy with the powerful Kotlin DSL. Install the tools and get started in minutes!</li> </ul>"},{"location":"play/","title":"Players guide","text":""},{"location":"develop/characters/","title":"Characters","text":"<p>Characters' main purpose is to talk with the player. Dialogue is not mandatory, for example you may want to model an impassive guard who never says a word, but as already stated, Dialoge DSL is the most complex of them all, so we'll break it down in this section.</p>"},{"location":"develop/characters/#general-character-properties","title":"General character properties","text":"<p>If we don't take into account the dialogue, the Character DSL is very simple: just a name and a description, as we already saw in the previous examples.</p> <p>Furthermore, just like with items, it's possible to use the <code>matchers</code> functions to define alternative names that refer to the character.</p> <p>Character ID</p> <p>The ID of any character must always start with <code>c-</code> and contain only lowecase letters, numbers and dashes.</p>"},{"location":"develop/characters/#dialogue-general-idea","title":"Dialogue: general idea","text":"<p>In general, a dialogue can contain two types of objects</p> <ul> <li>a question: even if it's often the case, it's not mandatory for a question to require an answer. In Kastle, a question is   just a phrase spoken by a character different from the player</li> <li>an answer: every question except the final ones carries one or more answers, that are phrases said by the player</li> </ul> <p>Each question object carries its own answers and each answer references the next question by its ID. The dialogue ends when the question does not have answers or has a reward (an item that the player earns from the dialogue).</p> <p>Question ID</p> <p>The ID of any question must always start with <code>d-</code> and contain only lowecase letters, numbers and dashes.</p>"},{"location":"develop/characters/#defining-a-dialogue","title":"Defining a dialogue","text":"<p>A dialogue always starts with a <code>dialogue</code> block inside the <code>character</code> block. The absolute first thing that we should do after we instantiated the <code>dialogue</code> is to instantiate a question. The first question must be declared using the <code>firstQuestion</code> function, all the subsequent ones should use <code>question</code>, but they work exactly the same.</p> <ul> <li>First of all you need to define the text of the question through the <code>text</code> property</li> <li>You can add answers by using the <code>answer</code> function as many times as you want. To define the answer:<ul> <li>Define the text through the property <code>text</code></li> <li>Define the next question through the property <code>nextQuestion</code> (referenced by ID)</li> </ul> </li> <li>If you don't add any answers, the question is the last one in the dialogue. In this case you can define a reward through the <code>reward</code> function, that works exactly like instantiating an item. </li> </ul> <p>Let's review the complete example that we did in Exapanding the game: <pre><code>dialogue {\n    firstQuestion(\"d-first\") {\n        text = \"Hey player! are you ready for the adventure?\"\n        answer {\n            text = \"Yes!\"\n            nextQuestion = \"d-ifyes\"\n        }\n        answer {\n            text = \"No...\"\n            nextQuestion = \"d-ifno\"\n        }\n    }\n\n    question(\"d-ifyes\") {\n        text = \"Ok, take this and go the the next room!\"\n        reward(\"i-diploma\") {\n            name = \"Diploma\"\n            description = \"\"\"\n                It's a nice diploma with decorated borders. It says:\n                'Well done, player! \n\n                You are ready for a ton of fun playing Kastle games!'\n            \"\"\".trimIndent()\n        }\n    }\n\n    question(\"d-ifno\") {\n        text = \"No problem, I'll wait until you're ready, but you're missing a lot of fun!\"\n    }\n}\n</code></pre></p>"},{"location":"develop/distributing/","title":"Distributing your game","text":"<p>At the moment there's no official way to distribute Kastle games. You can choose any method you want to let gamers have your JAR file and the fully qualified name of the class: these are the only 2 pieces of information needed to install any Kastle game.</p>"},{"location":"develop/expanding/","title":"Expanding the game","text":"<p>The game that we created in the previous section is just the bare minimum for Kastle to work. Let's build upon that and explore some of the other features of Kastle.</p>"},{"location":"develop/expanding/#adding-items","title":"Adding items","text":"<p>A room can contain items. Let's put a table in the initial room:</p> <pre><code>room(\"r-start\") {\n    name = \"Initial room\"\n    description = \"This is the first room that the player sees\"\n\n    item(\"i-table\") {\n        name = \"Table\"\n        description = \"A nice wooden table\"\n    }\n}\n</code></pre>"},{"location":"develop/expanding/#adding-npcs","title":"Adding NPCs","text":"<p>Also NPCs can be found in a room. Let's add one right under the <code>item</code> block:</p> <pre><code>character(\"c-doorman\") {\n    name = \"Jack\"\n    description = \"Jack is the official Kastle's doorman!\"\n}\n</code></pre>"},{"location":"develop/expanding/#adding-dialogue","title":"Adding dialogue","text":"<p>An NPC like this is not that much useful, right? We want the characters of our stories to be dynamic and interactive. The following block adds a simple dialogue to the doorsman. You can add it inside the <code>character</code> block:</p> <pre><code>character(\"c-doorman\") {\n    name = \"Jack\"\n    description = \"Jack is the official Kastle's doorman!\"\n    dialogue {\n        firstQuestion(\"d-first\") { // (1)!\n            text = \"Hey player! are you ready for the adventure?\"\n            answer {\n                text = \"Yes!\"\n                nextQuestion = \"d-ifyes\" // (2)!\n            }\n            answer {\n                text = \"No...\"\n                nextQuestion = \"d-ifno\"\n            }\n        }\n\n        question(\"d-ifyes\") {\n            text = \"Ok, take this and go the the next room!\"\n            reward(\"i-diploma\") { // (3)!\n                name = \"Diploma\"\n                description = \"\"\"\n                    It's a nice diploma with decorated borders. It says:\n                    'Well done, player!\n\n                    You reached the end of your first Kastle game.\n                    Move to the north to win the game!'\n                \"\"\".trimIndent() // (4)!\n            }\n        }\n\n        question(\"d-ifno\") {\n            text = \"No problem, I'll wait until you're ready, but you're missing a lot of fun!\"\n        }\n    }\n}\n</code></pre> <ol> <li>The <code>firstQuestion</code> block is mandatory to let Kastle know where to start</li> <li>Here we are defining the ID of the next question. Make sure to define a question with this ID later on!</li> <li>If the player reaches this branch of the dialogue, they get rewarded with an item. Inside the <code>reward</code> block,    you can define an item with the exact same DSL that we used before.</li> <li>Remember that the DSL is first and foremost Kotlin code! We can leverage all the features of the language,    such as multiline strings and the <code>trimIndent</code> function in this case.</li> </ol> <p>The Dialogue DSL is for sure the the most complex in Kastle, but it really gives depth to your characters and your story!</p> <p>Source code</p> <p>You can find the complete source code of this example on Github.</p>"},{"location":"develop/first-game/","title":"Your first game","text":"<p>We develop our game by implementing the <code>provideConfiguration</code> function of the <code>GameProvider</code>. Let's use the <code>game</code> function, the entry point of our DSL, to instantiate a new game:</p> <pre><code>class ExampleGame : GameProvider {\n    override fun provideConfiguration(): GameConfiguration = game(\"r-start\") {\n        // Your game will go here\n    }\n}\n</code></pre> <p>Tha string <code>\"r-start\"</code> that we are passing to the function is the ID of the first room, the one where the player will start their adventure. Let's give a definition of that room.</p>"},{"location":"develop/first-game/#defining-rooms","title":"Defining rooms","text":"<p>Let's start defining the initial room:</p> <pre><code>class ExampleGame : GameProvider {\n    override fun provideConfiguration(): GameConfiguration = game(\"r-start\") {\n        // Create a room with \"r-start\" ID\n        room(\"r-start\") {\n            name = \"Initial room\"\n            description = \"This is the first room that the player sees\"\n        }\n    }\n}\n</code></pre> <p>Then we define another room so that the player can move around:</p> <pre><code>room(\"r-next\") {\n    name = \"Another room\"\n    description = \"This is a room that the player can move to\"\n}\n</code></pre> <p>Let's link the rooms so that the player can move around. The second room will be to the north of the first:</p> <pre><code>room(\"r-start\") {\n    name = \"Initial room\"\n    description = \"This is the first room that the player sees\"\n    // Linking the north direction to the \"r-next\" room\n    north(\"r-next\") {\n        behavior = LinkBehavior.CONSTANT\n        state = LinkState.OPEN\n    }\n}\n\nroom(\"r-next\") {\n    name = \"Another room\"\n    description = \"This is a room that the player can move to\"\n}\n</code></pre> <p>And to make sure that our game can end, let's add a winning condition: when the player reaches the <code>\"r-next\"</code> room, the game ends. Let's add this block under the second room definition:</p> <pre><code>winIf {\n    playerEnters = \"r-next\"\n}\n</code></pre>"},{"location":"develop/first-game/#defining-the-player","title":"Defining the player","text":"<p>You can rest assured that every adventure has its hero! We'll define ours with the following lines:</p> <pre><code>player {\n    name = \"Enrico\"\n    description = \"Enrico is the author of Kastle and also an awesome hero for this game\"\n}\n</code></pre> <p>I'm giving my name to the hero, but feel free to put yours!</p>"},{"location":"develop/first-game/#building-the-game","title":"Building the game","text":"<p>This little example might be not that fun to play, but it really is what it takes to create a fully functional Kastle game, so let's build it!</p> <p>At the end of the day, a Kastle game is really just a Gradle project, so we build it by running <code>gradlew build</code>. If the command is executed without errors, then you'll find the jar file containing the game under <code>build/lib/&lt;project name&gt;-&lt;version&gt;.jar</code>.</p> <p>Source code</p> <p>You can find the complete source code of this example on Github.</p>"},{"location":"develop/items/","title":"Items","text":"<p>In Kastle, items can be used in two main ways:</p> <ul> <li>to convey information</li> <li>to open/close doors</li> </ul> <p>The basic items that we already defined are perfect to convey information: they have a name and a description and we can use these two properties to let the player discover details about the game. As an example, think about an incision on a wall. In the description we can put what the incision says and maybe that's a hint about how to go to the next room.</p> <p>In the following paragraphs, we'll learn how to make more complex items.</p> <p>Item ID</p> <p>The ID of any item must always start with <code>i-</code> and contain only lowecase letters, numbers and dashes.</p>"},{"location":"develop/items/#grabbing-items","title":"Grabbing items","text":"<p>In order to use an item to open a door, we must make that item storable in the player inventory. We do that exactly with the <code>storable</code> property:</p> <pre><code>item(\"i-key\") {\n    name = \"Key\"\n    description = \"This item opens a door\"\n    storable = true\n}\n</code></pre> <p>An item with this property set can be grabbed, carried around and used.</p>"},{"location":"develop/items/#making-items-easier-to-find","title":"Making items easier to find","text":"<p>Items are found by the player in the environment by using their name. We can make the life of the player easier by allowing multiple names to reference a specific item. In particular, an item will respond to its name and all the strings that are defined in the <code>matchers</code> property</p> <pre><code>item(\"i-sword\") {\n  name = \"Sword\"\n  matchers(\"blade\", \"weapon\")\n}\n</code></pre>"},{"location":"develop/metadata/","title":"Metadata","text":"<p>Each game can have some metadata that will be printed at the beginning of the game. In this section we'll learn something more about them.</p> <p>The available and configurable metadata are:</p> <ul> <li>the game name</li> <li>the author's name</li> <li>the game version</li> <li>the publication date</li> <li>the Kastle versions that this verision of the game is compatible with</li> </ul> <p>None of these data is mandatory and their purpose is purely documentation (e.g. even if we specify the Kastle versions, Kastle won't prevent us from running the game in an incompatible version).</p> <p>The <code>metadata</code> block must be put directly into the <code>game</code> block. Here's an example:</p> <pre><code>metadata {\n    author = \"Enrico Saggiorato\"\n    name = \"Tutorial Game\"\n    version = \"1.0.0\"\n    kastleVersions = listOf(\"1.0.0\", \"1.0.1\")\n    published = LocalDate(2024, 5, 24)\n}\n</code></pre>"},{"location":"develop/multiple-files/","title":"Splitting the game across multiple files","text":"<p>As your game grows, maintaining and expanding it can become challenging. With the Kastle DSL, you can easily split the game across multiple files that come together in your GameProvider class.</p> <p>It's highly recommended to start by developing the game within the provideConfiguration function, and then, as needed, refactor parts into separate files. A valuable example is the Dialogue DSL: it usually takes up much space and could lead to losing the general idea of the game configuration. Let's get back to our example and extract the dialogue into another file. We start from this snippet:</p> <pre><code>character(\"c-doorman\") {\n    name = \"Jack\"\n    description = \"Jack is the official Kastle's doorman!\"\n\n    dialogue {\n        firstQuestion(\"d-first\") {\n            text = \"Hey player! are you ready for the adventure?\"\n            answer {\n                text = \"Yes!\"\n                nextQuestion = \"d-ifyes\"\n            }\n            answer {\n                text = \"No...\"\n                nextQuestion = \"d-ifno\"\n            }\n        }\n\n        question(\"d-ifyes\") {\n            text = \"Ok, take this and go the the next room!\"\n            reward(\"i-diploma\") {\n                name = \"Diploma\"\n                description = \"\"\"\n        It's a nice diploma with decorated borders. It says:\n        'Well done, player!\n\n        You reached the end of your first Kastle game.\n        Move to the north to win the game!'\n    \"\"\".trimIndent()\n            }\n        }\n\n        question(\"d-ifno\") {\n            text = \"No problem, I'll wait until you're ready, but you're missing a lot of fun!\"\n        }\n    }\n}\n</code></pre> <p>The <code>dialogue</code> function is in the scope of the <code>character</code> block. Let's take a look at the definition of the <code>character</code> function:</p> <pre><code>fun character(characterId: String, init: CharacterScope.() -&gt; Unit)\n</code></pre> <p>Its <code>init</code> block has a <code>CharacterScope</code> receiver, so if we want to extract our dialogue into another file, we just have to define an extension function for the <code>CharacterScope</code>, for example:</p> <pre><code>import io.github.essay97.kastle.dsl.CharacterScope\n\nfun CharacterScope.doormanDialogue() {\n    dialogue {\n        firstQuestion(\"d-first\") {\n            text = \"Hey player! are you ready for the adventure?\"\n            answer {\n                text = \"Yes!\"\n                nextQuestion = \"d-ifyes\"\n            }\n            answer {\n                text = \"No...\"\n                nextQuestion = \"d-ifno\"\n            }\n        }\n\n        question(\"d-ifyes\") {\n            text = \"Ok, take this and go the the next room!\"\n            reward(\"i-diploma\") {\n                name = \"Diploma\"\n                description = \"\"\"\n                    It's a nice diploma with decorated borders. It says:\n                    'Well done, player!\n\n                    You reached the end of your first Kastle game.\n                    Move to the north to win the game!'\n                \"\"\".trimIndent()\n            }\n        }\n\n        question(\"d-ifno\") {\n            text = \"No problem, I'll wait until you're ready, but you're missing a lot of fun!\"\n        }\n    }\n}\n</code></pre> <p>And then our character would become:</p> <pre><code>character(\"c-doorman\") {\n    name = \"Jack\"\n    description = \"Jack is the official Kastle's doorman!\"\n\n    doormanDialogue()\n}\n</code></pre> <p>Much more readable! We could go further and extract each question into its own function but the functioning is always the same: look at the API docs for the receiver type and define an extension function.</p>"},{"location":"develop/multiple-files/#reusing-code","title":"Reusing code","text":"<p>Extracting some parts of the DSL into separate functions can enhance code reuse. As an example, imagine that we want to place a guard in each room of our game. Every guard has the same behavior, but each one has their own name. We colud define a function like the following:</p> <pre><code>fun RoomScope.guard(id: String, name: String) {\n    character(id) {\n        this.name = name\n        description = \"This guard won't let you pass\"\n    }\n}\n</code></pre>"},{"location":"develop/patterns/","title":"Game Patterns","text":"<p>The functionalities of Kastle are currently quite limited, but if used correctly, they can be very flexible. Below are some patterns that allow for interesting solutions.</p>"},{"location":"develop/patterns/#chain-of-objects","title":"Chain of objects","text":"<p>Example: The player inspects a painting and discovers a stain. Then they inspect the stain and find that a bugging device is embedded in the clump of paint, etc.</p> <p>The major downside of this is that if the player tries to inspect the bugging device (perhaps randomly or because a friend told them about it), Kastle will allow them to inspect it.</p>"},{"location":"develop/patterns/#fake-movements","title":"\u201cFake\u201d movements","text":"<p>Imagine having a chest in a room that can only be opened with a key. Kastle doesn't allow for opening and closing objects, but you can place the chest in a \"room\" that is accessed with a key. Narratively, the player will always be in the same place, only moving close to the chest, but this \u201cplace near the chest\u201d is modeled as a room in Kastle.</p>"},{"location":"develop/patterns/#story-items","title":"Story items","text":"<p>It's possible to use items as fictitious objects to advance the story. For example, in each room, we can define an item named \"plot\" that in its description contains the part of the story to be discovered in that room. You can use the room's description to instruct the player on how to use this feature, for instance, by inserting a phrase like \"Type inspect plot to proceed with the story.\"</p>"},{"location":"develop/patterns/#multiple-requirements","title":"Multiple requirements","text":"<p>If you want to require the player to find more than one item (for example, all pieces of a puzzle) to proceed, you can set up a series of successive rooms, each requiring a specific item as the key for the next one. For instance, you are in the main room, and to enter the final room, you need to collect four puzzle pieces. The door to the next room will be locked: it opens using piece 1 as the key. Once you open and pass through the door, you are not in the final room yet, but in an intermediate room with another locked door, which opens with piece 2, and so on.</p>"},{"location":"develop/project-setup/","title":"Project setup","text":"<p>A Kastle game is basically a Kotlin project. If you are already familiar with Kotlin, you can go on and create a Gradle project as you usally do. If this is your first time writing a Kotlin project, you'll probably need the IntelliJ IDEA Community Edition IDE, since it gives the best developer experience when writing Kotlin code.</p> <p>You can follow the official documentation for the Kotlin project setup.</p>"},{"location":"develop/project-setup/#installing-kastle-dependencies","title":"Installing Kastle dependencies","text":"<p>Once you created the project, go to your <code>build.gradle.kts</code> file and add the following line into the <code>dependencies</code> block and reload the Gradle project:</p> <pre><code>dependencies {\n    implementation(\"io.github.essay97:kastle-lib:0.0.2\")\n}\n</code></pre>"},{"location":"develop/project-setup/#implement-the-gameprovider","title":"Implement the GameProvider","text":"<p>This last step makes the project an actual Kastle game: the dependency that we installed in the previous step allows access to the <code>GameProvider</code> interface, that we need to implement.</p> <p>The following is an example:</p> <pre><code>package com.example.mypackage // (1)!\n\nimport io.github.essay97.kastle.service.GameProvider\n\nclass ExampleGame : GameProvider {\n    override fun provideConfiguration(): GameConfiguration {\n        TODO(\"Implement your game here!\")\n    }\n}\n</code></pre> <ol> <li>Substitute this with your own package name. Make it unique so that your class does not clash with the ones from    other developers.</li> </ol>"},{"location":"develop/project-setup/#let-the-engine-discover-the-game","title":"Let the engine discover the game","text":"<p>Just implementing the GameProvider interface is not sufficient though. To make sure that the engine can discover your game, you need to create a file in the <code>resources/META-INF/services</code> folder called <code>io.github.essay97.kastle.service.GameProvider</code> and write a single line that is the fully qualified name of your class (<code>&lt;package name&gt;.&lt;class name&gt;</code>).</p> <p>If we continue with the previous example, the folder structure would be:</p> <pre><code>src\n\u2514\u2500\u2500 main\n    \u251c\u2500\u2500 kotlin\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ExampleGame.kt\n    \u2514\u2500\u2500 resources\n        \u2514\u2500\u2500 META-INF\n            \u2514\u2500\u2500 services\n                \u2514\u2500\u2500 io.github.essay97.kastle.service.GameProvider # (1)!\n</code></pre> <ol> <li>The content of this file is <code>com.example.mypackage.ExampleGame</code></li> </ol>"},{"location":"develop/rooms/","title":"Rooms","text":"<p>Defining rooms is the core of worldbuilding for a Kastle game. Keep in mind that a room in Kastle does not have to model a physical room: think about it more like a generic \"place\".</p> <p>Every place that the player could interact with, in Kastle is a room: a forest, a village, even a portion of a room could be a room!</p> <p>Given the importance of this DSL, let's dive into it and learn how to make better rooms.</p> <p>Room ID</p> <p>The ID of any room must always start with <code>r-</code> and contain only lowecase letters, numbers and dashes.</p>"},{"location":"develop/rooms/#connecting-a-room-to-the-others","title":"Connecting a room to the others","text":"<p>The Room DSL provides 4 functions (one for each direction) to link rooms together: <code>north</code>, <code>south</code>, <code>west</code> and <code>east</code>. They all work the same way and define a \"door\" between the room and the other one in the specified direction. The door can work in different ways based on the following configurations:</p> <ul> <li>state: indicates if the door is open or locked. The values are provided by an enum with <code>LinkState.OPEN</code> and <code>LinkState.LOCKED</code></li> <li>behavior: indicates if the door state can be changed. The <code>LinkBehavior</code> enum provides the following values:<ul> <li><code>OPENABLE</code></li> <li><code>LOCKABLE</code></li> <li><code>COMPLETE</code></li> <li><code>CONSTANT</code></li> </ul> </li> <li>triggers: the list of items that can be used as a key to change the state of the door, if its behavior permits it. The items are specified by their id.</li> </ul> <p>If these values are not specified, the default connection is an <code>OPEN</code>, <code>CONSTANT</code> door.</p> <p>Warning</p> <p>The doors are not symmetrical by default: if you define a <code>north</code> door for a room, you still have to define a <code>south</code> door for the connected room. This might seem redundant, but it allows for modeling doors that can only be traversed in one direction or that lead to different destinations depending on the direction of traversal.</p>"},{"location":"develop/rooms/#adding-characters-and-items","title":"Adding characters and items","text":"<p>As we already saw, it's possible to put characters and items into rooms. This is the main way to characterize a room. Follow the dedicated guides to know how to create these objects. </p>"},{"location":"develop/start-end/","title":"Starting and ending the game","text":"<p>In this section we'll see how to introduce the player to the game world and how to set victory requirements.</p>"},{"location":"develop/start-end/#introducing-the-game","title":"Introducing the game","text":"<p>Kastle allows a preface: a sentence or small text that introduces the game. You can use it to describe the backstory, give some context about the world in which the game is set and so on.</p> <p>You can do that with the <code>preface</code> keyword right into the <code>game</code> block:</p> <pre><code>game {\n    preface = \"\"\"\n        This is the preface of this game.\n        As you can see here, by exploiting Kotlin multiline strings, we can provide a quite long text as a preface,\n        so in a real game we would have plenty of space to contextualize our game!\n    \"\"\".trimIndent\n}\n</code></pre>"},{"location":"develop/start-end/#setting-winning-conditions","title":"Setting winning conditions","text":"<p>A Kastle game can end because of two victory conditions:</p> <ul> <li>the player has a specific object in the inventory</li> <li>the player is in a specific room   It is sufficient that the player fulfills one of the defined requirements and the game ends.</li> </ul> <p>We can define such requirements thanks to the <code>winIf</code> block inside the <code>game</code> block:</p> <pre><code>winIf {\n    playerEnters = \"r-next\"\n    playerOwns = \"i-medal\" // (1)!\n}\n</code></pre> <ol> <li>This item hasn't been defined yet, but don't worry, we'll address it later!</li> </ol> <p>Notice that the winner room and the winner item are referenced by their ID and that we are not forced to use both.</p>"},{"location":"getting-started/first-game/","title":"Your first game","text":""},{"location":"getting-started/installation/","title":"Installation","text":""}]}